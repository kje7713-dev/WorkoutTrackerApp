//
//  WorkoutTrackerApp_Monolith_Fixed.swift
//  Generated by ChatGPT to replace broken multi-file setup.
//  This is a single-file version of the app with models, auto-programming,
//  basic metrics, block builder, Today view, and a simple workout logger.
//

import SwiftUI
import SwiftData

// =====================================================
// MARK: - Block / Plan Models
// =====================================================

@Model
final class BlockTemplate {
    @Attribute(.unique) var id: UUID
    var name: String
    var weeksCount: Int
    var createdAt: Date
    var createdByUser: Bool
    var notes: String?

    @Relationship(deleteRule: .cascade)
    var days: [DayTemplate]

    init(
        id: UUID = UUID(),
        name: String,
        weeksCount: Int,
        createdAt: Date = .now,
        createdByUser: Bool = true,
        notes: String? = nil,
        days: [DayTemplate] = []
    ) {
        self.id = id
        self.name = name
        self.weeksCount = weeksCount
        self.createdAt = createdAt
        self.createdByUser = createdByUser
        self.notes = notes
        self.days = days
    }
}

@Model
final class DayTemplate {
    @Attribute(.unique) var id: UUID
    var weekIndex: Int
    var dayIndex: Int
    var title: String
    var dayDescription: String
    /// Machine-friendly label for the day type, e.g. "heavy_upper"
    var roleKey: String
    var orderIndex: Int

    @Relationship(inverse: \BlockTemplate.days)
    var block: BlockTemplate?

    @Relationship(deleteRule: .cascade)
    var exercises: [PlannedExercise]

    init(
        id: UUID = UUID(),
        weekIndex: Int,
        dayIndex: Int,
        title: String,
        dayDescription: String,
        roleKey: String = "",
        orderIndex: Int,
        block: BlockTemplate? = nil,
        exercises: [PlannedExercise] = []
    ) {
        self.id = id
        self.weekIndex = weekIndex
        self.dayIndex = dayIndex
        self.title = title
        self.dayDescription = dayDescription
        self.roleKey = roleKey
        self.orderIndex = orderIndex
        self.block = block
        self.exercises = exercises
    }
}

@Model
final class ExerciseTemplate {
    @Attribute(.unique) var id: UUID
    var name: String
    var category: String?
    var defaultReps: Int?
    var defaultSets: Int?
    var defaultRPE: Double?
    var defaultTempo: String?
    var notes: String?

    init(
        id: UUID = UUID(),
        name: String,
        category: String? = nil,
        defaultReps: Int? = nil,
        defaultSets: Int? = nil,
        defaultRPE: Double? = nil,
        defaultTempo: String? = nil,
        notes: String? = nil
    ) {
        self.id = id
        self.name = name
        self.category = category
        self.defaultReps = defaultReps
        self.defaultSets = defaultSets
        self.defaultRPE = defaultRPE
        self.defaultTempo = defaultTempo
        self.notes = notes
    }
}

@Model
final class PlannedExercise {
    @Attribute(.unique) var id: UUID
    var orderIndex: Int

    @Relationship(inverse: \DayTemplate.exercises)
    var day: DayTemplate?

    @Relationship
    var exerciseTemplate: ExerciseTemplate?

    var notes: String?

    @Relationship(deleteRule: .cascade)
    var prescribedSets: [PrescribedSet]

    init(
        id: UUID = UUID(),
        orderIndex: Int,
        exerciseTemplate: ExerciseTemplate?,
        day: DayTemplate?,
        notes: String? = nil,
        prescribedSets: [PrescribedSet] = []
    ) {
        self.id = id
        self.orderIndex = orderIndex
        self.exerciseTemplate = exerciseTemplate
        self.day = day
        self.notes = notes
        self.prescribedSets = prescribedSets
    }
}

@Model
final class PrescribedSet {
    @Attribute(.unique) var id: UUID
    var setIndex: Int
    var targetReps: Int
    var targetWeight: Double
    var targetRPE: Double?
    var tempo: String?
    var notes: String?

    @Relationship(inverse: \PlannedExercise.prescribedSets)
    var plannedExercise: PlannedExercise?

    init(
        id: UUID = UUID(),
        setIndex: Int,
        targetReps: Int,
        targetWeight: Double,
        targetRPE: Double? = nil,
        tempo: String? = nil,
        notes: String? = nil,
        plannedExercise: PlannedExercise? = nil
    ) {
        self.id = id
        self.setIndex = setIndex
        self.targetReps = targetReps
        self.targetWeight = targetWeight
        self.targetRPE = targetRPE
        self.tempo = tempo
        self.notes = notes
        self.plannedExercise = plannedExercise
    }
}

// =====================================================
// MARK: - Logged Session Models
// =====================================================

@Model
final class WorkoutSession {
    @Attribute(.unique) var id: UUID
    var date: Date
    var weekIndex: Int
    var dayIndex: Int
    var isCompleted: Bool
    var notes: String?

    @Relationship
    var blockTemplate: BlockTemplate?

    @Relationship
    var dayTemplate: DayTemplate?

    @Relationship(deleteRule: .cascade)
    var exercises: [SessionExercise]

    init(
        id: UUID = UUID(),
        date: Date = .now,
        weekIndex: Int,
        dayIndex: Int,
        isCompleted: Bool = false,
        notes: String? = nil,
        blockTemplate: BlockTemplate? = nil,
        dayTemplate: DayTemplate? = nil,
        exercises: [SessionExercise] = []
    ) {
        self.id = id
        self.date = date
        self.weekIndex = weekIndex
        self.dayIndex = dayIndex
        self.isCompleted = isCompleted
        self.notes = notes
        self.blockTemplate = blockTemplate
        self.dayTemplate = dayTemplate
        self.exercises = exercises
    }
}

@Model
final class SessionExercise {
    @Attribute(.unique) var id: UUID
    var orderIndex: Int

    @Relationship(inverse: \WorkoutSession.exercises)
    var session: WorkoutSession?

    @Relationship
    var exerciseTemplate: ExerciseTemplate?

    /// Optional, lets you rename it for the session
    var nameOverride: String?

    @Relationship(deleteRule: .cascade)
    var sets: [SessionSet]

    init(
        id: UUID = UUID(),
        orderIndex: Int,
        session: WorkoutSession?,
        exerciseTemplate: ExerciseTemplate?,
        nameOverride: String? = nil,
        sets: [SessionSet] = []
    ) {
        self.id = id
        self.orderIndex = orderIndex
        self.session = session
        self.exerciseTemplate = exerciseTemplate
        self.nameOverride = nameOverride
        self.sets = sets
    }
}

@Model
final class SessionSet {
    @Attribute(.unique) var id: UUID
    var setIndex: Int
    var targetReps: Int
    var targetWeight: Double
    var targetRPE: Double?

    var actualReps: Int
    var actualWeight: Double
    var actualRPE: Double?
    var completed: Bool
    var timestamp: Date?
    var notes: String?

    @Relationship(inverse: \SessionExercise.sets)
    var sessionExercise: SessionExercise?

    init(
        id: UUID = UUID(),
        setIndex: Int,
        targetReps: Int,
        targetWeight: Double,
        targetRPE: Double? = nil,
        actualReps: Int,
        actualWeight: Double,
        actualRPE: Double? = nil,
        completed: Bool = false,
        timestamp: Date? = nil,
        notes: String? = nil,
        sessionExercise: SessionExercise? = nil
    ) {
        self.id = id
        self.setIndex = setIndex
        self.targetReps = targetReps
        self.targetWeight = targetWeight
        self.targetRPE = targetRPE
        self.actualReps = actualReps
        self.actualWeight = actualWeight
        self.actualRPE = actualRPE
        self.completed = completed
        self.timestamp = timestamp
        self.notes = notes
        self.sessionExercise = sessionExercise
    }
}

// =====================================================
// MARK: - Auto-program config & service
// =====================================================

/// Single source of truth for BlockGoal used by UI + service
enum BlockGoal: String, CaseIterable, Identifiable, Codable {
    case strength
    case hypertrophy
    case peaking

    var id: String { rawValue }
}

struct AutoProgramConfig {
    let name: String                 // "SBD Block 1 – 4 Week Strength"
    let goal: BlockGoal
    let weeksCount: Int              // e.g. 4
    let daysPerWeek: Int             // e.g. 4
    let mainLifts: [String]          // e.g. ["Squat", "Bench", "Deadlift"]

    /// Training maxes for main lifts (same names as mainLifts)
    let trainingMaxes: [String: Double]  // ["Squat": 405, "Bench": 285, ...]
}

enum AutoProgramError: Error {
    case noTrainingMax(String)
}

struct AutoProgramService {

    /// Generates a BlockTemplate (+ days/exercises/sets) and saves it to SwiftData.
    /// Returns the created BlockTemplate so you can use it in UI.
    @discardableResult
    static func generateBlock(
        in context: ModelContext,
        config: AutoProgramConfig
    ) throws -> BlockTemplate {

        // 1. Create the block
        let block = BlockTemplate(
            name: config.name,
            weeksCount: config.weeksCount,
            createdAt: Date.now,
            createdByUser: true,
            notes: "Auto-programmed \(config.goal.rawValue.capitalized) block"
        )

        context.insert(block)

        // 2. Define a simple weekly % pattern based on goal
        let percentPattern: [Double]
        switch config.goal {
        case .strength:
            // training block ramp
            percentPattern = [0.70, 0.75, 0.80, 0.85]
        case .hypertrophy:
            // a bit lighter, more volume
            percentPattern = [0.65, 0.70, 0.70, 0.75]
        case .peaking:
            // heavier, taper last week
            percentPattern = [0.80, 0.85, 0.90, 0.70]
        }

        // 3. Simple day “roles” for 4-day SBD style block (can expand later)
        let dayRoles: [Int: String] = [
            1: "Heavy Upper",
            2: "Volume Lower",
            3: "Heavy Lower",
            4: "Accessory / Conditioning"
        ]

        // 4. Ensure we have (or create) ExerciseTemplate entries
        var exerciseTemplatesByName: [String: ExerciseTemplate] = [:]

        func template(for name: String, category: String?) -> ExerciseTemplate {
            if let cached = exerciseTemplatesByName[name] {
                return cached
            }
            // Try to find existing template in store
            let descriptor = FetchDescriptor<ExerciseTemplate>(
                predicate: #Predicate { $0.name == name }
            )
            let existing = try? context.fetch(descriptor).first
            if let existing {
                exerciseTemplatesByName[name] = existing
                return existing
            }

            let tmpl = ExerciseTemplate(
                name: name,
                category: category,
                defaultReps: nil,
                defaultSets: nil,
                defaultRPE: nil,
                defaultTempo: nil,
                notes: nil
            )
            context.insert(tmpl)
            exerciseTemplatesByName[name] = tmpl
            return tmpl
        }

        // 5. Build weeks & days
        for weekIndex in 1...config.weeksCount {
            // Clamp % array if weeksCount > pattern size
            let pct = percentPattern[min(weekIndex - 1, percentPattern.count - 1)]

            for dayIndex in 1...config.daysPerWeek {
                let roleName = dayRoles[dayIndex] ?? "Day \(dayIndex)"
                let roleKey = canonicalRoleKey(for: roleName)   // machine-readable tag

                let day = DayTemplate(
                    weekIndex: weekIndex,
                    dayIndex: dayIndex,
                    title: roleName,
                    dayDescription: description(for: roleKey, goal: config.goal),
                    roleKey: roleKey,
                    orderIndex: dayIndex,
                    block: block
                )
                block.days.append(day)

                // Decide which lifts live on this day
                let plannedLifts = liftsForDay(
                    roleKey: roleKey,
                    mainLifts: config.mainLifts
                )

                for (exerciseOrder, lift) in plannedLifts.enumerated() {
                    let exerciseName = lift.name
                    let category = lift.category
                    let sets = lift.sets
                    let reps = lift.reps

                    let tm = config.trainingMaxes[lift.tmKey]
                    if tm == nil && lift.usesTM {
                        throw AutoProgramError.noTrainingMax(lift.tmKey)
                    }

                    let eTemplate = template(for: exerciseName, category: category)

                    let planned = PlannedExercise(
                        orderIndex: exerciseOrder,
                        exerciseTemplate: eTemplate,
                        day: day,
                        notes: nil
                    )
                    day.exercises.append(planned)

                    // Build prescribed sets
                    for setIndex in 1...sets {
                        let weight: Double
                        if lift.usesTM, let tm {
                            weight = tm * pct
                        } else {
                            weight = lift.fixedWeight ?? 0
                        }

                        let set = PrescribedSet(
                            setIndex: setIndex,
                            targetReps: reps,
                            targetWeight: weight,
                            targetRPE: lift.targetRPE,
                            tempo: nil,
                            notes: nil,
                            plannedExercise: planned
                        )
                        planned.prescribedSets.append(set)
                    }
                }
            }
        }

        try context.save()
        return block
    }

    // MARK: - Helpers

    /// Turn a human label into a stable machine key
    private static func canonicalRoleKey(for role: String) -> String {
        role
            .lowercased()
            .replacingOccurrences(of: " / ", with: "_")
            .replacingOccurrences(of: " ", with: "_")
    }

    /// Simple description templates keyed by roleKey (not the pretty title)
    private static func description(for roleKey: String, goal: BlockGoal) -> String {
        switch (roleKey, goal) {
        case ("heavy_upper", .strength):
            return "Primary bench variation heavy for low reps plus upper-body accessories."
        case ("volume_lower", .strength):
            return "Squat-focused volume work in moderate rep ranges."
        case ("heavy_lower", .strength):
            return "Primary squat or deadlift heavy for low reps with posterior chain accessories."
        case ("accessory_conditioning", _):
            return "Single-leg work, core, and conditioning intervals. Keep RPE moderate."
        default:
            return "\(roleKey) session focused on \(goal.rawValue)."
        }
    }

    /// Internal template to drive per-day exercise choices.
    private struct DayLift {
        let name: String
        let category: String?
        let sets: Int
        let reps: Int
        let usesTM: Bool
        let tmKey: String
        let fixedWeight: Double?
        let targetRPE: Double?
    }

    private static func liftsForDay(
        roleKey: String,
        mainLifts: [String]
    ) -> [DayLift] {
        let squat = mainLifts.first { $0.lowercased().contains("squat") } ?? "Back Squat"
        let bench = mainLifts.first { $0.lowercased().contains("bench") } ?? "Bench Press"
        let dead  = mainLifts.first { $0.lowercased().contains("dead")  } ?? "Deadlift"

        switch roleKey {
        case "heavy_upper":
            return [
                DayLift(name: bench, category: "Press", sets: 5, reps: 3,
                        usesTM: true, tmKey: bench, fixedWeight: nil, targetRPE: 8.0),
                DayLift(name: "Incline DB Press", category: "Press", sets: 4, reps: 8,
                        usesTM: false, tmKey: "", fixedWeight: 0, targetRPE: 7.0),
                DayLift(name: "Barbell Row", category: "Pull", sets: 4, reps: 8,
                        usesTM: false, tmKey: "", fixedWeight: 0, targetRPE: 7.0)
            ]

        case "volume_lower":
            return [
                DayLift(name: squat, category: "Squat", sets: 4, reps: 6,
                        usesTM: true, tmKey: squat, fixedWeight: nil, targetRPE: 7.5),
                DayLift(name: "RDL", category: "Hinge", sets: 4, reps: 8,
                        usesTM: false, tmKey: "", fixedWeight: 0, targetRPE: 7.0),
                DayLift(name: "Walking Lunge", category: "Single-leg", sets: 3, reps: 10,
                        usesTM: false, tmKey: "", fixedWeight: 0, targetRPE: 7.0)
            ]

        case "heavy_lower":
            return [
                DayLift(name: dead, category: "Hinge", sets: 5, reps: 3,
                        usesTM: true, tmKey: dead, fixedWeight: nil, targetRPE: 8.0),
                DayLift(name: "Paused Squat", category: "Squat", sets: 3, reps: 5,
                        usesTM: false, tmKey: "", fixedWeight: 0, targetRPE: 8.0),
                DayLift(name: "Back Extension", category: "Accessory", sets: 3, reps: 12,
                        usesTM: false, tmKey: "", fixedWeight: 0, targetRPE: 7.0)
            ]

        case "accessory_conditioning":
            return [
                DayLift(name: "Bulgarian Split Squat", category: "Single-leg", sets: 3, reps: 10,
                        usesTM: false, tmKey: "", fixedWeight: 0, targetRPE: 7.0),
                DayLift(name: "Hanging Leg Raise", category: "Core", sets: 3, reps: 12,
                        usesTM: false, tmKey: "", fixedWeight: 0, targetRPE: 7.0),
                DayLift(name: "Bike Intervals", category: "Conditioning", sets: 6, reps: 30,
                        usesTM: false, tmKey: "", fixedWeight: 0, targetRPE: 7.0)
            ]

        default:
            // fallback: just cycle main lifts
            return [
                DayLift(name: squat, category: "Squat", sets: 4, reps: 5,
                        usesTM: true, tmKey: squat, fixedWeight: nil, targetRPE: 7.5),
                DayLift(name: bench, category: "Press", sets: 4, reps: 5,
                        usesTM: true, tmKey: bench, fixedWeight: nil, targetRPE: 7.5),
                DayLift(name: dead, category: "Hinge", sets: 3, reps: 3,
                        usesTM: true, tmKey: dead, fixedWeight: nil, targetRPE: 8.0)
            ]
        }
    }
}

// =====================================================
// MARK: - AI Export helpers (for ChatGPT later)
// =====================================================

/// Top-level DTO we can send to ChatGPT
struct AIBlockExport: Codable {
    struct Day: Codable {
        let weekIndex: Int
        let dayIndex: Int
        let title: String
        let roleKey: String
        let description: String
        let exercises: [Exercise]
    }

    struct Exercise: Codable {
        let name: String
        let sets: Int
        let reps: Int
        let targetWeight: Double
    }

    let id: UUID
    let name: String
    let weeksCount: Int
    /// Optional string if you later want to pipe BlockGoal through
    let goal: String?
    let days: [Day]
}

extension BlockTemplate {
    /// Export this block into a compact format the ChatGPT API can reason about.
    func toAIExport(includeWeights: Bool = true) -> AIBlockExport {
        let sortedDays = days.sorted { lhs, rhs in
            if lhs.weekIndex == rhs.weekIndex {
                return lhs.dayIndex < rhs.dayIndex
            }
            return lhs.weekIndex < rhs.weekIndex
        }

        let dayExports: [AIBlockExport.Day] = sortedDays.map { day in
            let exerciseExports: [AIBlockExport.Exercise] = day.exercises
                .sorted { $0.orderIndex < $1.orderIndex }
                .map { planned in
                    let sortedSets = planned.prescribedSets.sorted { $0.setIndex < $1.setIndex }
                    let setsCount = sortedSets.count
                    let firstSet = sortedSets.first

                    return AIBlockExport.Exercise(
                        name: planned.exerciseTemplate?.name ?? "Exercise",
                        sets: setsCount,
                        reps: firstSet?.targetReps ?? 0,
                        targetWeight: includeWeights ? (firstSet?.targetWeight ?? 0.0) : 0.0
                    )
                }

            return AIBlockExport.Day(
                weekIndex: day.weekIndex,
                dayIndex: day.dayIndex,
                title: day.title,
                roleKey: day.roleKey,
                description: day.dayDescription,
                exercises: exerciseExports
            )
        }

        // We’re not currently storing BlockGoal on the BlockTemplate,
        // so goal is nil for now. You can wire that in later if you like.
        return AIBlockExport(
            id: id,
            name: name,
            weeksCount: weeksCount,
            goal: nil,
            days: dayExports
        )
    }
}

// =====================================================
// MARK: - Shared UI (QuoteHeader, Metrics)
// =====================================================

struct QuoteHeader: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text("Savage By Design")
                .font(.caption)
                .foregroundStyle(.secondary)
            Text("Win The Day")
                .font(.title2)
                .fontWeight(.bold)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

struct MetricPoint: Identifiable {
    let id = UUID()
    let weekIndex: Int
    let expected: Double
    let actual: Double

    static func makeSeries(weeks: [Int], expected: [Double], actual: [Double]) -> [MetricPoint] {
        zip(weeks.indices, weeks).map { idx, week in
            MetricPoint(
                weekIndex: week,
                expected: expected.indices.contains(idx) ? expected[idx] : 0,
                actual: actual.indices.contains(idx) ? actual[idx] : 0
            )
        }
    }
}

struct MetricCard: View {
    let title: String
    let subtitle: String
    let points: [MetricPoint]

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(title)
                .font(.headline)
            Text(subtitle)
                .font(.subheadline)
                .foregroundStyle(.secondary)

            if points.isEmpty {
                Text("No data yet.")
                    .font(.footnote)
                    .foregroundStyle(.secondary)
            } else {
                ForEach(points) { point in
                    HStack {
                        Text("Week \(point.weekIndex)")
                            .font(.caption)
                        Spacer()
                        Text("Exp \(Int(point.expected))%")
                            .font(.caption2)
                        Text("Act \(Int(point.actual))%")
                            .font(.caption2)
                            .foregroundStyle(.accent)
                    }
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.secondarySystemBackground))
        )
    }
}

// =====================================================
// MARK: - Block list + builder + dashboard
// =====================================================

enum BlockBuilderMode: String, CaseIterable, Identifiable {
    case template = "Templates"
    case custom   = "Custom"
    case ai       = "AI"

    var id: String { rawValue }
}

struct BlockListView: View {
    @Environment(\.modelContext) private var context

    @Query(sort: \BlockTemplate.name, order: .forward)
    private var blocks: [BlockTemplate]

    @State private var showingBuilder = false

    var body: some View {
        NavigationStack {
            List {
                if blocks.isEmpty {
                    Text("No blocks yet.\nTap + to create one.")
                        .multilineTextAlignment(.center)
                        .foregroundStyle(.secondary)
                } else {
                    ForEach(blocks) { blockTemplate in
                        NavigationLink(blockTemplate.name) {
                            DashboardView(block: blockTemplate)
                        }
                    }
                    .onDelete(perform: deleteBlocks)
                }
            }
            .navigationTitle("Blocks")
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    EditButton()
                }
                ToolbarItem(placement: .topBarTrailing) {
                    Button {
                        showingBuilder = true
                    } label: {
                        Image(systemName: "plus")
                    }
                }
            }
            .sheet(isPresented: $showingBuilder) {
                BlockBuilderView()
                    .presentationDetents([.medium, .large])
            }
        }
    }

    private func deleteBlocks(at offsets: IndexSet) {
        for index in offsets {
            let block = blocks[index]
            context.delete(block)
        }
        do {
            try context.save()
        } catch {
            print("Error deleting blocks: \(error)")
        }
    }
}

struct BlockBuilderView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context

    @State private var mode: BlockBuilderMode = .ai   // default to AI

    // Shared basic fields
    @State private var name: String = ""
    @State private var weeks: Int = 4
    @State private var daysPerWeek: Int = 4

    // AI-specific fields
    @State private var goal: BlockGoal = .strength
    @State private var squatTM: String = "405"
    @State private var benchTM: String = "285"
    @State private var deadliftTM: String = "495"

    @State private var errorMessage: String?
    @State private var isGenerating = false

    var body: some View {
        NavigationStack {
            Form {
                // Mode picker
                Section {
                    Picker("Mode", selection: $mode) {
                        ForEach(BlockBuilderMode.allCases) { mode in
                            Text(mode.rawValue).tag(mode)
                        }
                    }
                    .pickerStyle(.segmented)
                }

                Section("Basic") {
                    TextField("Block name (required, e.g. SBD Block 1…)", text: $name)
                        .textInputAutocapitalization(.words)

                    Stepper("Weeks: \(weeks)", value: $weeks, in: 1...12)
                    Stepper("Days per week: \(daysPerWeek)", value: $daysPerWeek, in: 1...7)
                }

                if mode == .template {
                    Section("Templates") {
                        Text("Template library UI to come.")
                            .font(.footnote)
                            .foregroundStyle(.secondary)
                    }
                }

                if mode == .custom {
                    Section("Custom Block") {
                        Text("Manual day + exercise builder UI to come.")
                            .font(.footnote)
                            .foregroundStyle(.secondary)
                    }
                }

                if mode == .ai {
                    aiSection
                }

                if let errorMessage {
                    Section {
                        Text(errorMessage)
                            .foregroundStyle(.red)
                            .font(.footnote)
                    }
                }
            }
            .navigationTitle("New Block")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
            }
        }
    }

    private var aiSection: some View {
        Section("AI Auto Programming") {
            Picker("Goal", selection: $goal) {
                ForEach(BlockGoal.allCases) { goal in
                    Text(goal.rawValue.capitalized).tag(goal)
                }
            }

            Text("Training Maxes")
                .font(.subheadline)

            HStack {
                Text("Squat")
                Spacer()
                TextField("e.g. 405", text: $squatTM)
                    .multilineTextAlignment(.trailing)
                    .keyboardType(.numberPad)
            }

            HStack {
                Text("Bench")
                Spacer()
                TextField("e.g. 285", text: $benchTM)
                    .multilineTextAlignment(.trailing)
                    .keyboardType(.numberPad)
            }

            HStack {
                Text("Deadlift")
                Spacer()
                TextField("e.g. 495", text: $deadliftTM)
                    .multilineTextAlignment(.trailing)
                    .keyboardType(.numberPad)
            }

            Button {
                generateAIBlock()
            } label: {
                if isGenerating {
                    ProgressView()
                } else {
                    Text("Generate Block")
                        .frame(maxWidth: .infinity, alignment: .center)
                }
            }
            .disabled(isGenerating || name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
        }
    }

    // MARK: - Actions

    private func generateAIBlock() {
        errorMessage = nil

        guard
            let squat = Double(squatTM),
            let bench = Double(benchTM),
            let dead  = Double(deadliftTM)
        else {
            errorMessage = "Please enter valid numbers for training maxes."
            return
        }

        guard !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            errorMessage = "Block name is required."
            return
        }

        isGenerating = true

        let config = AutoProgramConfig(
            name: name,
            goal: goal,
            weeksCount: weeks,
            daysPerWeek: daysPerWeek,
            mainLifts: ["Back Squat", "Bench Press", "Deadlift"],
            trainingMaxes: [
                "Back Squat": squat,
                "Bench Press": bench,
                "Deadlift": dead
            ]
        )

        do {
            _ = try AutoProgramService.generateBlock(in: context, config: config)
            isGenerating = false
            dismiss()
        } catch {
            isGenerating = false
            errorMessage = "Failed to generate block: \(error)"
        }
    }
}

// MARK: - Dashboard (per block)

struct DashboardView: View {
    let block: BlockTemplate

    @Environment(\.modelContext) private var context
    @Query(sort: \WorkoutSession.weekIndex)
    private var allSessions: [WorkoutSession]

    // Sessions belonging to this block
    private var sessionsForBlock: [WorkoutSession] {
        allSessions.filter { $0.blockTemplate == block }
    }

    // All weeks for this block
    private var weeks: [Int] {
        guard block.weeksCount > 0 else { return [] }
        return Array(1...block.weeksCount)
    }

    // Expected reps / volume from the PROGRAM (Plan)

    private var expectedRepsPerWeek: [Int: Double] {
        var dict: [Int: Double] = [:]
        for day in block.days {
            let reps = day.exercises
                .flatMap { $0.prescribedSets }
                .reduce(0.0) { $0 + Double($1.targetReps) }
            dict[day.weekIndex, default: 0] += reps
        }
        return dict
    }

    private var expectedVolumePerWeek: [Int: Double] {
        var dict: [Int: Double] = [:]
        for day in block.days {
            let vol = day.exercises
                .flatMap { $0.prescribedSets }
                .reduce(0.0) { partial, set in
                    partial + (Double(set.targetReps) * set.targetWeight)
                }
            dict[day.weekIndex, default: 0] += vol
        }
        return dict
    }

    private var totalExpectedRepsInBlock: Double {
        expectedRepsPerWeek.values.reduce(0, +)
    }

    private var totalExpectedVolumeInBlock: Double {
        expectedVolumePerWeek.values.reduce(0, +)
    }

    // Expected % curves

    private var expectedExercisePctByWeek: [Int: Double] {
        guard totalExpectedRepsInBlock > 0 else { return [:] }
        var dict: [Int: Double] = [:]
        var cumulative = 0.0
        for week in weeks {
            cumulative += expectedRepsPerWeek[week] ?? 0
            dict[week] = (cumulative / totalExpectedRepsInBlock) * 100.0
        }
        return dict
    }

    private var expectedVolumePctByWeek: [Int: Double] {
        guard totalExpectedVolumeInBlock > 0 else { return [:] }
        var dict: [Int: Double] = [:]
        var cumulative = 0.0
        for week in weeks {
            cumulative += expectedVolumePerWeek[week] ?? 0
            dict[week] = (cumulative / totalExpectedVolumeInBlock) * 100.0
        }
        return dict
    }

    // Actual % curves from logged sessions

    private var actualExercisePctByWeek: [Int: Double] {
        guard totalExpectedRepsInBlock > 0 else { return [:] }
        var dict: [Int: Double] = [:]

        for week in weeks {
            let weeksUpTo = sessionsForBlock.filter { $0.weekIndex <= week }
            let completedSets = weeksUpTo
                .flatMap { $0.exercises }
                .flatMap { $0.sets }
                .filter { $0.completed }

            let reps = completedSets.reduce(0.0) { $0 + Double($1.actualReps) }
            dict[week] = (reps / totalExpectedRepsInBlock) * 100.0
        }

        return dict
    }

    private var actualVolumePctByWeek: [Int: Double] {
        guard totalExpectedVolumeInBlock > 0 else { return [:] }
        var dict: [Int: Double] = [:]

        for week in weeks {
            let weeksUpTo = sessionsForBlock.filter { $0.weekIndex <= week }
            let completedSets = weeksUpTo
                .flatMap { $0.exercises }
                .flatMap { $0.sets }
                .filter { $0.completed }

            let volume = completedSets.reduce(0.0) { partial, set in
                partial + (Double(set.actualReps) * set.actualWeight)
            }
            dict[week] = (volume / totalExpectedVolumeInBlock) * 100.0
        }

        return dict
    }

    private var exerciseCompletionPoints: [MetricPoint] {
        guard !weeks.isEmpty else { return [] }
        let expected = weeks.map { expectedExercisePctByWeek[$0] ?? 0 }
        let actual   = weeks.map { actualExercisePctByWeek[$0]   ?? 0 }
        return MetricPoint.makeSeries(weeks: weeks, expected: expected, actual: actual)
    }

    private var volumeCompletionPoints: [MetricPoint] {
        guard !weeks.isEmpty else { return [] }
        let expected = weeks.map { expectedVolumePctByWeek[$0] ?? 0 }
        let actual   = weeks.map { actualVolumePctByWeek[$0]   ?? 0 }
        return MetricPoint.makeSeries(weeks: weeks, expected: expected, actual: actual)
    }

    // “Current day” label – just first day in block
    private var currentDayLabel: String {
        guard let firstDay = block.days.sorted(by: {
            if $0.weekIndex == $1.weekIndex {
                return $0.dayIndex < $1.dayIndex
            }
            return $0.weekIndex < $1.weekIndex
        }).first else {
            return "No days defined"
        }

        return "Week \(firstDay.weekIndex) • Day \(firstDay.dayIndex) – \(firstDay.title)"
    }

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {

                    QuoteHeader()

                    NavigationLink {
                        BlockDetailView(block: block)
                    } label: {
                        VStack(alignment: .leading, spacing: 4) {
                            Text(block.name)
                                .font(.title)
                                .fontWeight(.bold)

                            Text(currentDayLabel)
                                .font(.headline)
                                .foregroundStyle(.secondary)
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 16)
                                .fill(Color(.secondarySystemBackground))
                        )
                    }

                    MetricCard(
                        title: "% Exercises Completed in Block",
                        subtitle: "Expected vs Actual",
                        points: exerciseCompletionPoints
                    )

                    MetricCard(
                        title: "% Volume Completed in Block",
                        subtitle: "Expected vs Actual",
                        points: volumeCompletionPoints
                    )

                    Spacer(minLength: 20)
                }
                .padding()
            }
            .navigationTitle("")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
}

// MARK: - Block Detail (week/day + summary)

struct BlockDetailView: View {
    let block: BlockTemplate

    @State private var selectedDayIndex: Int
    @State private var selectedWeek: Int
    @State private var dragOffset: CGFloat = 0

    @Environment(\.modelContext) private var context

    private var weeks: [Int] {
        let unique = Set(block.days.map { $0.weekIndex })
        return unique.sorted()
    }

    private func days(for week: Int) -> [DayTemplate] {
        block.days
            .filter { $0.weekIndex == week }
            .sorted { $0.dayIndex < $1.dayIndex }
    }

    private var selectedDay: DayTemplate? {
        block.days.first {
            $0.weekIndex == selectedWeek && $0.dayIndex == selectedDayIndex
        }
    }

    init(block: BlockTemplate) {
        self.block = block

        let sortedWeeks = Set(block.days.map { $0.weekIndex }).sorted()
        let initialWeek = sortedWeeks.first ?? 1
        _selectedWeek = State(initialValue: initialWeek)

        let firstDayIndex = block.days
            .filter { $0.weekIndex == initialWeek }
            .map { $0.dayIndex }
            .sorted()
            .first ?? 1
        _selectedDayIndex = State(initialValue: firstDayIndex)
    }

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 20) {

                // Week + current day summary
                VStack(alignment: .leading, spacing: 6) {
                    Text("Week \(selectedWeek)")
                        .font(.largeTitle)
                        .fontWeight(.bold)

                    if let day = selectedDay {
                        Text("Day \(day.dayIndex) – \(day.title)")
                            .font(.headline)
                            .foregroundStyle(.secondary)
                    } else {
                        Text("Select a day")
                            .font(.headline)
                            .foregroundStyle(.secondary)
                    }

                    Text("Swipe left or right to change weeks.")
                        .font(.footnote)
                        .foregroundStyle(.secondary)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 16)
                        .fill(Color(.secondarySystemBackground))
                )

                // Day selector
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 8) {
                        ForEach(days(for: selectedWeek)) { day in
                            Button {
                                selectedDayIndex = day.dayIndex
                            } label: {
                                Text("Day \(day.dayIndex)")
                                    .font(.subheadline)
                                    .fontWeight(.semibold)
                                    .padding(.vertical, 8)
                                    .padding(.horizontal, 14)
                                    .background(
                                        Capsule().fill(
                                            selectedDayIndex == day.dayIndex
                                            ? Color.accentColor
                                            : Color(.secondarySystemBackground)
                                        )
                                    )
                                    .foregroundColor(
                                        selectedDayIndex == day.dayIndex ? .white : .primary
                                    )
                            }
                        }
                    }
                    .padding(.vertical, 4)
                }

                // Day description + summary-level exercises + Start button
                if let day = selectedDay {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Workout Description")
                            .font(.headline)

                        Text(day.dayDescription)
                            .font(.body)
                            .foregroundStyle(.secondary)
                            .multilineTextAlignment(.leading)
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 16)
                            .fill(Color(.secondarySystemBackground))
                    )

                    // Summary-level exercise list
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Today's Exercises")
                            .font(.headline)

                        ForEach(day.exercises.sorted(by: { $0.orderIndex < $1.orderIndex })) { planned in
                            let sets = planned.prescribedSets.count
                            let reps = planned.prescribedSets.first?.targetReps ?? 0
                            let weight = planned.prescribedSets.first?.targetWeight ?? 0

                            HStack {
                                VStack(alignment: .leading, spacing: 2) {
                                    Text(planned.exerciseTemplate?.name ?? "Exercise")
                                        .font(.subheadline)
                                        .fontWeight(.semibold)

                                    Text("\(sets) x \(reps) @ \(Int(weight)) lb")
                                        .font(.footnote)
                                        .foregroundStyle(.secondary)
                                }

                                Spacer()
                            }
                            .padding(.vertical, 6)
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 16)
                            .fill(Color(.secondarySystemBackground))
                    )

                    NavigationLink {
                        let session = existingOrNewSession(for: day)
                        WorkoutSessionView(session: session, day: day)
                    } label: {
                        Text("Start This Workout")
                            .font(.headline)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.accentColor)
                            .foregroundColor(.white)
                            .cornerRadius(16)
                    }
                    .padding(.top, 4)
                }

                Spacer(minLength: 20)
            }
            .padding()
        }
        .offset(x: dragOffset)
        .gesture(
            DragGesture()
                .onChanged { value in
                    dragOffset = value.translation.width
                }
                .onEnded { value in
                    let threshold: CGFloat = 80
                    var newWeek = selectedWeek

                    if value.translation.width < -threshold {
                        // swipe left
                        if let next = weeks.first(where: { $0 > selectedWeek }) {
                            newWeek = next
                        }
                    } else if value.translation.width > threshold {
                        // swipe right
                        if let prev = weeks.reversed().first(where: { $0 < selectedWeek }) {
                            newWeek = prev
                        }
                    }

                    withAnimation(.spring()) {
                        selectedWeek = newWeek
                        // reset selected day to first in that week
                        if let first = days(for: newWeek).first {
                            selectedDayIndex = first.dayIndex
                        }
                        dragOffset = 0
                    }
                }
        )
        .navigationTitle(block.name)
        .navigationBarTitleDisplayMode(.inline)
    }

    // MARK: - SwiftData helpers

    private func existingOrNewSession(for day: DayTemplate) -> WorkoutSession {
        if let existing = fetchSession(for: day) {
            return existing
        } else {
            return createSession(for: day)
        }
    }

    private func fetchSession(for day: DayTemplate) -> WorkoutSession? {
        let week = day.weekIndex
        let dayIndex = day.dayIndex

        let descriptor = FetchDescriptor<WorkoutSession>(
            predicate: #Predicate { session in
                session.weekIndex == week &&
                session.dayIndex == dayIndex
            }
        )

        do {
            let results = try context.fetch(descriptor)
            return results.first
        } catch {
            print("Error fetching session: \(error)")
            return nil
        }
    }

    private func createSession(for day: DayTemplate) -> WorkoutSession {
        let session = WorkoutSession(
            weekIndex: day.weekIndex,
            dayIndex: day.dayIndex,
            blockTemplate: block,
            dayTemplate: day
        )

        for planned in day.exercises.sorted(by: { $0.orderIndex < $1.orderIndex }) {
            let sessionExercise = SessionExercise(
                orderIndex: planned.orderIndex,
                session: session,
                exerciseTemplate: planned.exerciseTemplate,
                nameOverride: planned.exerciseTemplate?.name
            )

            for pSet in planned.prescribedSets.sorted(by: { $0.setIndex < $1.setIndex }) {
                let set = SessionSet(
                    setIndex: pSet.setIndex,
                    targetReps: pSet.targetReps,
                    targetWeight: pSet.targetWeight,
                    targetRPE: pSet.targetRPE,
                    actualReps: pSet.targetReps,
                    actualWeight: pSet.targetWeight,
                    actualRPE: nil,
                    completed: false,
                    timestamp: nil,
                    notes: nil,
                    sessionExercise: sessionExercise
                )
                sessionExercise.sets.append(set)
            }

            session.exercises.append(sessionExercise)
        }

        context.insert(session)
        do {
            try context.save()
        } catch {
            print("Error saving new session: \(error)")
        }

        return session
    }
}

// =====================================================
// MARK: - Today View
// =====================================================

struct TodayView: View {
    @Environment(\.modelContext) private var context

    // Grab all blocks; we'll pick an "active" one
    @Query(sort: \BlockTemplate.name, order: .forward)
    private var blocks: [BlockTemplate]

    @State private var isPushingSession = false
    @State private var currentSession: WorkoutSession?
    @State private var currentDay: DayTemplate?

    /// Very simple: just use the first block for now
    private var activeBlock: BlockTemplate? {
        blocks.first
    }

    /// Sorted days in the active block
    private var sortedDaysInActiveBlock: [DayTemplate] {
        guard let block = activeBlock else { return [] }
        return block.days.sorted {
            if $0.weekIndex == $1.weekIndex {
                return $0.dayIndex < $1.dayIndex
            }
            return $0.weekIndex < $1.weekIndex
        }
    }

    var body: some View {
        NavigationStack {
            Group {
                if blocks.isEmpty {
                    VStack(spacing: 12) {
                        Text("No Block Yet")
                            .font(.title2)
                            .fontWeight(.semibold)
                        Text("Create a block in the Blocks tab to get your first programmed workout.")
                            .font(.subheadline)
                            .multilineTextAlignment(.center)
                            .foregroundStyle(.secondary)
                    }
                    .padding()
                } else if let block = activeBlock,
                          let (day, session) = nextDayAndSession(for: block) {
                    VStack(alignment: .leading, spacing: 24) {
                        QuoteHeader()

                        VStack(alignment: .leading, spacing: 4) {
                            Text("Today's Block")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                            Text(block.name)
                                .font(.title2)
                                .fontWeight(.bold)
                        }

                        VStack(alignment: .leading, spacing: 6) {
                            Text("Today’s Workout")
                                .font(.headline)

                            Text("Week \(day.weekIndex) • Day \(day.dayIndex) – \(day.title)")
                                .font(.subheadline)
                                .foregroundStyle(.secondary)

                            Text(day.dayDescription)
                                .font(.footnote)
                                .foregroundStyle(.secondary)
                                .multilineTextAlignment(.leading)
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding()
                        .background(
                            RoundedRectangle(cornerRadius: 16)
                                .fill(Color(.secondarySystemBackground))
                        )

                        NavigationLink(
                            destination: WorkoutSessionView(session: session, day: day),
                            isActive: $isPushingSession
                        ) {
                            Text("Start Today’s Workout")
                                .font(.headline)
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(Color.accentColor)
                                .foregroundColor(.white)
                                .cornerRadius(16)
                        }

                        Spacer()
                    }
                    .padding()
                    .onAppear {
                        self.currentSession = session
                        self.currentDay = day
                    }
                } else {
                    Text("No workout for today could be found.")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                        .padding()
                }
            }
            .navigationTitle("Today")
            .navigationBarTitleDisplayMode(.inline)
        }
    }

    // MARK: - Helpers

    private func nextDayAndSession(for block: BlockTemplate) -> (DayTemplate, WorkoutSession)? {
        let days = sortedDaysInActiveBlock
        guard !days.isEmpty else { return nil }

        for day in days {
            if let existing = fetchSession(for: day, in: block) {
                if !existing.isCompleted {
                    return (day, existing)
                } else {
                    continue
                }
            } else {
                let newSession = createSession(for: day, in: block)
                return (day, newSession)
            }
        }

        if let lastDay = days.last {
            let session = fetchSession(for: lastDay, in: block) ?? createSession(for: lastDay, in: block)
            return (lastDay, session)
        }

        return nil
    }

    private func fetchSession(for day: DayTemplate) -> WorkoutSession? {
    private func fetchSession(for day: DayTemplate, in block: BlockTemplate) -> WorkoutSession? {
        do {
            // Fetch all sessions and filter in Swift instead of using #Predicate
            let descriptor = FetchDescriptor<WorkoutSession>()
            let allSessions = try context.fetch(descriptor)

            return allSessions.first { session in
                session.blockTemplate?.id == block.id &&
                session.dayTemplate?.id == day.id
            }
        } catch {
            print("Error fetching session for TodayView: \(error)")
            return nil
        }
    }
    private func createSession(for day: DayTemplate, in block: BlockTemplate) -> WorkoutSession {
        let session = WorkoutSession(
            weekIndex: day.weekIndex,
            dayIndex: day.dayIndex,
            isCompleted: false,
            notes: nil,
            blockTemplate: block,
            dayTemplate: day
        )

        for planned in day.exercises.sorted(by: { $0.orderIndex < $1.orderIndex }) {
            let sessionExercise = SessionExercise(
                orderIndex: planned.orderIndex,
                session: session,
                exerciseTemplate: planned.exerciseTemplate,
                nameOverride: planned.exerciseTemplate?.name
            )

            for pSet in planned.prescribedSets.sorted(by: { $0.setIndex < $1.setIndex }) {
                let set = SessionSet(
                    setIndex: pSet.setIndex,
                    targetReps: pSet.targetReps,
                    targetWeight: pSet.targetWeight,
                    targetRPE: pSet.targetRPE,
                    actualReps: pSet.targetReps,
                    actualWeight: pSet.targetWeight,
                    actualRPE: nil,
                    completed: false,
                    timestamp: nil,
                    notes: nil,
                    sessionExercise: sessionExercise
                )
                sessionExercise.sets.append(set)
            }

            session.exercises.append(sessionExercise)
        }

        context.insert(session)
        do {
            try context.save()
        } catch {
            print("Error saving new session from TodayView: \(error)")
        }

        return session
    }
}

// =====================================================
// MARK: - Workout Session View
// =====================================================

struct WorkoutSessionView: View {
    @Bindable var session: WorkoutSession
    let day: DayTemplate

    @Environment(\.modelContext) private var context

    private var totalSets: Int {
        session.exercises.reduce(0) { $0 + $1.sets.count }
    }

    private var totalCompletedSets: Int {
        session.exercises.reduce(0) { partial, exercise in
            partial + exercise.sets.filter { $0.completed }.count
        }
    }

    var body: some View {
        List {
            Section {
                Text("Week \(session.weekIndex) • Day \(session.dayIndex)")
                Text(day.title)
                    .font(.headline)
                Text(day.dayDescription)
                    .font(.footnote)
                    .foregroundStyle(.secondary)
            }

            Section(header: Text("Progress")) {
                Text("Completed \(totalCompletedSets) of \(totalSets) sets")
            }

            ForEach(session.exercises) { exercise in
                Section(header: Text(exercise.nameOverride ?? exercise.exerciseTemplate?.name ?? "Exercise")) {
                    ForEach(exercise.sets) { set in
                        HStack {
                            VStack(alignment: .leading) {
                                Text("Set \(set.setIndex)")
                                Text("\(set.targetReps) reps @ \(Int(set.targetWeight)) lb")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                            }
                            Spacer()
                            Button {
                                set.completed.toggle()
                                set.timestamp = set.completed ? Date() : nil
                                try? context.save()
                            } label: {
                                Image(systemName: set.completed ? "checkmark.circle.fill" : "circle")
                            }
                        }
                    }
                }
            }
        }
        .navigationTitle("Workout")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            Button("Done") {
                session.isCompleted = true
                try? context.save()
            }
        }
    }
}

// =====================================================
// MARK: - Root ContentView & App
// =====================================================

struct ContentView: View {
    var body: some View {
        TabView {
            TodayView()
                .tabItem {
                    Label("Today", systemImage: "sun.max")
                }

            BlockListView()
                .tabItem {
                    Label("Blocks", systemImage: "square.grid.2x2")
                }
        }
    }
}

@main
struct WorkoutTrackerAppApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(for: [
            BlockTemplate.self,
            DayTemplate.self,
            ExerciseTemplate.self,
            PlannedExercise.self,
            PrescribedSet.self,
            WorkoutSession.self,
            SessionExercise.self,
            SessionSet.self
        ])
    }
}