import SwiftUI

// MARK: - Run Mode Container

struct BlockRunModeView: View {
    let block: Block

    @State private var weeks: [RunWeekState]
    @State private var currentWeekIndex: Int = 0
    @State private var currentDayIndex: Int = 0

    @State private var lastCommittedWeekIndex: Int = 0
    @State private var pendingWeekIndex: Int? = nil
    @State private var showSkipAlert: Bool = false

    init(block: Block) {
        self.block = block

        if let persisted = BlockRunModeView.loadPersistedWeeks(for: block.id) {
            _weeks = State(initialValue: persisted)
        } else {
            _weeks = State(initialValue: BlockRunModeView.buildWeeks(from: block))
        }
    }

    var body: some View {
        VStack(spacing: 0) {
            topBar

            if weeks.isEmpty || block.days.isEmpty {
                Text("This block has no days configured.")
                    .padding()
                Spacer()
            } else {
                TabView(selection: $currentWeekIndex) {
                    ForEach(weeks.indices, id: \.self) { weekIndex in
                        WeekRunView(
                            week: $weeks[weekIndex],
                            allDays: block.days,
                            currentDayIndex: $currentDayIndex
                        )
                        .tag(weekIndex)
                    }
                }
                .tabViewStyle(.page(indexDisplayMode: .never))
                .onChange(of: currentWeekIndex) { _, newValue in
                    handleWeekChange(newWeekIndex: newValue)
                }
                .alert("You can skip â but champions donât.", isPresented: $showSkipAlert) {
                    Button("Stay on Track", role: .cancel) {
                        pendingWeekIndex = nil
                    }
                    Button("Continue") {
                        if let target = pendingWeekIndex {
                            currentWeekIndex = target
                            lastCommittedWeekIndex = target
                            pendingWeekIndex = nil
                        }
                    }
                } message: {
                    Text("Week \(lastCommittedWeekIndex + 1) still has work open. Move forward anyway?")
                }
            }
        }
        .navigationBarTitleDisplayMode(.inline)
        .onDisappear {
            BlockRunModeView.saveWeeks(weeks, for: block.id)
        }
    }

    private var topBar: some View {
        VStack(alignment: .leading, spacing: 4) {
            // Block name BIG
            Text(block.name)
                .font(.largeTitle)
                .fontWeight(.black)
                .textCase(.uppercase)
                .kerning(1.2)

            // Full day name (primary)
            let fullDay: String = {
                guard block.days.indices.contains(currentDayIndex) else { return "" }
                return block.days[currentDayIndex].name
            }()

            Text(fullDay)
                .font(.headline)
                .fontWeight(.semibold)

            // Short code + week in secondary role
            let short: String = {
                guard block.days.indices.contains(currentDayIndex) else { return "" }
                return block.days[currentDayIndex].shortCode ?? ""
            }()

            Text("Week \(currentWeekIndex + 1) â¢ \(short.uppercased())")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .kerning(0.5)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(.horizontal, 16)
        .padding(.top, 8)
        .padding(.bottom, 4)
    }

    // MARK: - Week Change Logic

    private func handleWeekChange(newWeekIndex: Int) {
        // Only warn if user is trying to move forward
        guard newWeekIndex > lastCommittedWeekIndex else {
            lastCommittedWeekIndex = newWeekIndex
            return
        }

        // If any previous week is not completed, show warning
        let earlierIncomplete = weeks[0...lastCommittedWeekIndex].contains { !$0.isCompleted }
        if earlierIncomplete {
            pendingWeekIndex = newWeekIndex
            // snap back to last committed until they confirm
            currentWeekIndex = lastCommittedWeekIndex
            showSkipAlert = true
        } else {
            lastCommittedWeekIndex = newWeekIndex
        }
    }

    // MARK: - Build Initial Run State

    private static func buildWeeks(from block: Block) -> [RunWeekState] {
        guard !block.days.isEmpty else {
            return []
        }

        let weeksCount = max(block.numberOfWeeks, 1)

        return (0..<weeksCount).map { weekIndex in
            let dayStates: [RunDayState] = block.days.map { day in
                let exerciseStates: [RunExerciseState] = day.exercises.map { exercise in
                    let sets: [RunSetState]

                    switch exercise.type {
                    case .strength:
                        let strengthSets = exercise.strengthSets ?? []
                        sets = strengthSets.enumerated().map { idx, set in
                            let repsText = set.reps.map { "Reps: \($0)" } ?? ""
                            let weightText = set.weight.map { "Weight: \($0)" } ?? ""

                            let combined = [repsText, weightText]
                                .filter { !$0.isEmpty }
                                .joined(separator: " â¢ ")

                            let plannedReps = set.reps
                            let plannedWeight = set.weight

                            return RunSetState(
                                indexInExercise: idx,
                                displayText: combined.isEmpty ? "Strength set" : combined,
                                type: .strength,
                                plannedReps: plannedReps,
                                plannedWeight: plannedWeight,
                                actualReps: plannedReps,
                                actualWeight: plannedWeight
                            )
                        }

                    case .conditioning:
                        let condSets = exercise.conditioningSets ?? []
                        sets = condSets.enumerated().map { idx, set in
                            var parts: [String] = []

                            if let dur = set.durationSeconds {
                                if dur % 60 == 0 {
                                    let mins = dur / 60
                                    parts.append("\(mins) min")
                                } else {
                                    parts.append("\(dur) sec")
                                }
                            }
                            if let dist = set.distanceMeters {
                                parts.append("\(Int(dist)) m")
                            }
                            if let cal = set.calories {
                                parts.append("\(Int(cal)) cal")
                            }
                            if let rounds = set.rounds {
                                parts.append("\(rounds) rounds")
                            }

                            let combined = parts.isEmpty ? "Conditioning" : parts.joined(separator: " â¢ ")

                            let plannedTime = set.durationSeconds.map(Double.init)
                            let plannedDistance = set.distanceMeters
                            let plannedCalories = set.calories
                            let plannedRounds = set.rounds

                            return RunSetState(
                                indexInExercise: idx,
                                displayText: combined,
                                type: .conditioning,
                                plannedTimeSeconds: plannedTime,
                                plannedDistanceMeters: plannedDistance,
                                plannedCalories: plannedCalories,
                                plannedRounds: plannedRounds,
                                actualTimeSeconds: plannedTime,
                                actualDistanceMeters: plannedDistance,
                                actualCalories: plannedCalories,
                                actualRounds: plannedRounds
                            )
                        }

                    default:
                        sets = [
                            RunSetState(
                                indexInExercise: 0,
                                displayText: "Set",
                                type: exercise.type
                            )
                        ]
                    }

                    let name = exercise.customName ?? "Exercise"
                    let notes = exercise.notes ?? ""

                    return RunExerciseState(
                        name: name,
                        type: exercise.type,
                        notes: notes,
                        sets: sets
                    )
                }

                return RunDayState(
                    name: day.name,
                    shortCode: day.shortCode ?? "",
                    exercises: exerciseStates
                )
            }

            return RunWeekState(index: weekIndex, days: dayStates)
        }
    }

    // MARK: - Persistence

    private static func persistenceURL(for blockId: BlockID) -> URL {
        let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        return dir.appendingPathComponent("runstate-\(blockId.uuidString).json")
    }

    private static func loadPersistedWeeks(for blockId: BlockID) -> [RunWeekState]? {
        let url = persistenceURL(for: blockId)
        guard FileManager.default.fileExists(atPath: url.path) else { return nil }

        do {
            let data = try Data(contentsOf: url)
            return try JSONDecoder().decode([RunWeekState].self, from: data)
        } catch {
            print("â ï¸ Failed to load RunWeekState for block \(blockId): \(error)")
            return nil
        }
    }

    private static func saveWeeks(_ weeks: [RunWeekState], for blockId: BlockID) {
        let url = persistenceURL(for: blockId)
        do {
            let data = try JSONEncoder().encode(weeks)
            try data.write(to: url, options: [.atomic])
        } catch {
            print("â ï¸ Failed to save RunWeekState for block \(blockId): \(error)")
        }
    }
} // <--- BlockRunModeView ends here

// MARK: - Week View

struct WeekRunView: View {
    @Binding var week: RunWeekState
    let allDays: [DayTemplate]
    @Binding var currentDayIndex: Int

    var body: some View {
        VStack(spacing: 0) {
            DayTabBar(days: allDays, currentDayIndex: $currentDayIndex)
            Divider()
            content
        }
    }

    @ViewBuilder
    private var content: some View {
        if week.days.indices.contains(currentDayIndex) {
            DayRunView(day: $week.days[currentDayIndex])
        } else {
            Text("No days configured for this week.")
                .padding()
        }
    }
}

// MARK: - Day Tabs

struct DayTabBar: View {
    let days: [DayTemplate]
    @Binding var currentDayIndex: Int

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 8) {
                ForEach(Array(days.enumerated()), id: \.offset) { index, day in
                    dayButton(for: day, index: index)
                }
            }
            .padding(.horizontal)
        }
        .padding(.vertical, 8)
    }

    private func dayButton(for day: DayTemplate, index: Int) -> some View {
        let isSelected = index == currentDayIndex
        let label: String

        if let short = day.shortCode, !short.isEmpty {
            label = short
        } else {
            label = day.name
        }

        return Button(action: {
            currentDayIndex = index
        }) {
            Text(label)
                .font(.subheadline)
                .fontWeight(isSelected ? .bold : .regular)
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .background(
                    isSelected ? Color.black : Color.clear
                )
                .foregroundColor(isSelected ? Color.white : Color.primary)
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(Color.black, lineWidth: isSelected ? 0 : 1)
                )
                .cornerRadius(16)
        }
    }
}

struct DayRunView: View {
    @Binding var day: RunDayState

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                ForEach($day.exercises) { $exercise in
                    ExerciseRunCard(exercise: $exercise)
                }

                Button {
                    let newExerciseIndex = day.exercises.count + 1
                    let newExercise = RunExerciseState(
                        name: "New Exercise \(newExerciseIndex)",
                        type: .strength,
                        notes: "",
                        sets: [
                            RunSetState(
                                indexInExercise: 0,
                                displayText: "Set 1",
                                type: .strength
                            )
                        ]
                    )
                    day.exercises.append(newExercise)
                } label: {
                    Label("Add Exercise", systemImage: "plus")
                        .font(.subheadline.bold())
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 10)
                        .background(
                            RoundedRectangle(cornerRadius: 16)
                                .stroke(Color.primary, lineWidth: 1)
                        )
                }
                .padding(.top, 8)
            }
            .padding(.horizontal)
            .padding(.vertical)
        }
    }
}

struct ExerciseRunCard: View {
    @Binding var exercise: RunExerciseState

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Editable exercise name
            TextField("Exercise name", text: $exercise.name)
                .font(.headline)
                .textFieldStyle(.roundedBorder)
                .disableAutocorrection(true)

            // Existing notes from the template (if any)
            if !exercise.notes.isEmpty {
                Text(exercise.notes)
                    .font(.footnote)
                    .foregroundColor(.secondary)
            }

            // Editable notes during the session
            TextField("Add notes (RPE, cues, etc.)",
                      text: $exercise.notes,
                      axis: .vertical)
                .lineLimit(1...3)
                .font(.footnote)
                .textFieldStyle(.roundedBorder)

            // Sets
            ForEach($exercise.sets) { $set in
                SetRunRow(runSet: $set)

            }

            // Add/remove set controls
            HStack {
                Button {
                    let newIndex = exercise.sets.count
                    let newSet = RunSetState(
                        indexInExercise: newIndex,
                        displayText: "Set \(newIndex + 1)",
                        type: exercise.type
                    )
                    exercise.sets.append(newSet)
                } label: {
                    Label("Add Set", systemImage: "plus")
                        .font(.caption.bold())
                }

                Spacer()

                if exercise.sets.count > 1 {
                    Button {
                        _ = exercise.sets.popLast()
                    } label: {
                        Label("Remove Set", systemImage: "minus")
                            .font(.caption)
                    }
                }
            }
            .padding(.top, 4)
        }
        .padding()
    }
}

// MARK: - Helper Struct for Reusability (SetControlView is moved to file scope)

struct SetControlView: View {
    let label: String
    let unit: String
    @Binding var value: Double?
    let step: Double
    let formatter: NumberFormatter
    let min: Double

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            // Label
            Text(label)
                .font(.caption2)
                .foregroundColor(.secondary)

            // Controls
            HStack(spacing: 4) {
                Button {
                    if let currentValue = value {
                        value = max(min, currentValue - step)
                    } else {
                        value = min
                    }
                } label: {
                    Image(systemName: "minus.circle")
                }

                // FIX: Ensured the string result is calculated outside of Text and is not optional
                Text(value.flatMap { formatter.string(from: NSNumber(value: $0)) } ?? "-")
                    .font(.body.monospacedDigit())
                    .frame(width: 40)
                    .minimumScaleFactor(0.5)

                Button {
                    if let currentValue = value {
                        value = currentValue + step
                    } else {
                        value = min + step
                    }
                } label: {
                    Image(systemName: "plus.circle")
                }

                Text(unit)
                    .font(.body)
            }
        }
    }
}

struct SetRunRow: View {
    @Binding var runSet: RunSetState

    // Strength helpers (keeping these for clarity, though not directly used in the new UI)
    private var repsValue: Int {
        runSet.actualReps ?? runSet.plannedReps ?? 0
    }

    private var weightValue: Double {
        runSet.actualWeight ?? runSet.plannedWeight ?? 0
    }

    // Conditioning helpers (we show minutes for time)
    private var timeMinutesValue: Int {
        let seconds = runSet.actualTimeSeconds ?? runSet.plannedTimeSeconds ?? 0
        return Int(seconds / 60)
    }

    private var caloriesValue: Int {
        Int(runSet.actualCalories ?? runSet.plannedCalories ?? 0)
    }

    private var roundsValue: Int {
        runSet.actualRounds ?? runSet.plannedRounds ?? 0
    }

    // Common formatter for whole numbers (Reps, Rounds, Minutes)
    private static let integerFormatter: NumberFormatter = {
        let f = NumberFormatter()
        f.maximumFractionDigits = 0
        f.minimumFractionDigits = 0
        return f
    }()

    // Common formatter for weight (allows one decimal for precision, but minimal 0)
    private static let weightFormatter: NumberFormatter = {
        let f = NumberFormatter()
        f.maximumFractionDigits = 1
        f.minimumFractionDigits = 0
        return f
    }()


    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Header
            Text("Set \(runSet.indexInExercise + 1)")
                .font(.subheadline).bold()

            // Planned summary
            if !runSet.displayText.isEmpty {
                Text("Planned: \(runSet.displayText)")
                    .font(.footnote)
                    .foregroundColor(.secondary)
            }

            // Controls depend on type
            if runSet.type == .strength {
                strengthControls
            } else if runSet.type == .conditioning {
                conditioningControls
            }

            // Complete / Undo
            HStack {
                Spacer()
                if runSet.isCompleted {
                    Button("Undo") {
                        runSet.isCompleted = false
                    }
                    .font(.caption)
                } else {
                    Button("Complete") {
                        runSet.isCompleted = true
                    }
                    .font(.subheadline)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 6)
                    .background(
                        RoundedRectangle(cornerRadius: 16)
                            .stroke(Color.primary, lineWidth: 1)
                    )
                }
            }
        }
        .padding(10)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(uiColor: .secondarySystemBackground))
        )
        // Completed ribbon overlay
        .overlay(
            Group {
                if runSet.isCompleted {
                    Text("COMPLETED")
                        .font(.caption2).bold()
                        .padding(6)
                        .background(Color.black)
                        .foregroundColor(.white)
                        .rotationEffect(.degrees(22))
                        .offset(x: 8, y: -8)
                }
            },
            alignment: .topTrailing
        )
        .padding(.vertical, 2)
    }

    // MARK: - Strength UI (Modified to use VStack and SetControlView)

    private var strengthControls: some View {
        VStack(alignment: .leading, spacing: 16) {
            
            // Reps Control
            SetControlView(
                label: "REPETITIONS",
                unit: "reps",
                // FIX: Used the correct call to the extension method
                value: $runSet.actualReps.toDouble(),
                step: 1.0,
                formatter: Self.integerFormatter,
                min: 0.0
            )

            // Weight Control
            SetControlView(
                label: "WEIGHT",
                unit: "lb",
                value: $runSet.actualWeight,
                step: 5.0,
                formatter: Self.weightFormatter,
                min: 0.0
            )
        }
    }

    // MARK: - Conditioning UI (Modified to use SetControlView where possible)

    private var conditioningControls: some View {
        VStack(alignment: .leading, spacing: 6) {

            // Time (minutes) - Kept original implementation to avoid complex secondary binding
            HStack(spacing: 6) {
                Text("Time")
                    .font(.caption2)
                    .foregroundColor(.secondary)

                Button {
                    let mins = max(0, timeMinutesValue - 1)
                    runSet.actualTimeSeconds = Double(mins * 60)
                } label: {
                    Image(systemName: "minus.circle")
                }

                Text("\(timeMinutesValue)")
                    .font(.body.monospacedDigit())
                    .frame(width: 32)

                Button {
                    let mins = timeMinutesValue + 1
                    runSet.actualTimeSeconds = Double(mins * 60)
                } label: {
                    Image(systemName: "plus.circle")
                }

                Text("min")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }


            // Calories Control
            SetControlView(
                label: "CALORIES",
                unit: "cal",
                value: $runSet.actualCalories,
                step: 5.0,
                formatter: Self.integerFormatter,
                min: 0.0
            )

            // Rounds Control
            SetControlView(
                label: "ROUNDS",
                unit: "rounds",
                // FIX: Used the correct call to the extension method
                value: $runSet.actualRounds.toDouble(),
                step: 1.0,
                formatter: Self.integerFormatter,
                min: 0.0
            )
        }
    }
}

// MARK: - Run State Models (No changes here)

struct RunWeekState: Identifiable, Codable {
    let id = UUID()
    let index: Int
    var days: [RunDayState]

    var isCompleted: Bool {
        for day in days {
            for exercise in day.exercises {
                if exercise.sets.contains(where: { !$0.isCompleted }) {
                    return false
                }
            }
        }
        return true
    }
}

struct RunDayState: Identifiable, Codable{
    let id = UUID()
    let name: String
    let shortCode: String
    var exercises: [RunExerciseState]
}

struct RunExerciseState: Identifiable, Codable {
    let id = UUID()
    var name: String
    let type: ExerciseType
    var notes: String
    var sets: [RunSetState]
}

struct RunSetState: Identifiable, Codable {
    let id = UUID()
    let indexInExercise: Int
    let displayText: String
    let type: ExerciseType

    // Strength planned/actual
    var plannedReps: Int?
    var plannedWeight: Double?
    var actualReps: Int?
    var actualWeight: Double?

    // Conditioning planned/actual (seconds / meters)
    var plannedTimeSeconds: Double?
    var plannedDistanceMeters: Double?
    var plannedCalories: Double?
    var plannedRounds: Int?

    var actualTimeSeconds: Double?
    var actualDistanceMeters: Double?
    var actualCalories: Double?
    var actualRounds: Int?

    var isCompleted: Bool = false

    init(
        indexInExercise: Int,
        displayText: String,
        type: ExerciseType,
        plannedReps: Int? = nil,
        plannedWeight: Double? = nil,
        actualReps: Int? = nil,
        actualWeight: Double? = nil,
        plannedTimeSeconds: Double? = nil,
        plannedDistanceMeters: Double? = nil,
        plannedCalories: Double? = nil,
        plannedRounds: Int? = nil,
        actualTimeSeconds: Double? = nil,
        actualDistanceMeters: Double? = nil,
        actualCalories: Double? = nil,
        actualRounds: Int? = nil,
        isCompleted: Bool = false
    ) {
        self.indexInExercise = indexInExercise
        self.displayText = displayText
        self.type = type
        self.plannedReps = plannedReps
        self.plannedWeight = plannedWeight
        self.actualReps = actualReps
        self.actualWeight = actualWeight
        self.plannedTimeSeconds = plannedTimeSeconds
        self.plannedDistanceMeters = plannedDistanceMeters
        self.plannedCalories = plannedCalories
        self.plannedRounds = plannedRounds
        self.actualTimeSeconds = actualTimeSeconds
        self.actualDistanceMeters = actualDistanceMeters
        self.actualCalories = actualCalories
        self.actualRounds = actualRounds
        self.isCompleted = isCompleted
    }
}


// MARK: - BINDING EXTENSIONS (Moved to File Scope)

extension Binding where Value == Int? {
    /// Converts an optional Int binding to an optional Double binding.
    func toDouble() -> Binding<Double?> {
        return Binding<Double?>(
            get: { self.wrappedValue.map(Double.init) },
            // Force optional value back to Int?
            set: { self.wrappedValue = $0.map { Int($0) } }
        )
    }
}

extension Binding where Value == Double? {
    /// Utility to simplify passing Double? bindings to SetControlView
    func toDouble() -> Binding<Double?> {
        return self
    }
}