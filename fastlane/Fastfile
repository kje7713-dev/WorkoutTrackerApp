default_platform(:ios)

platform :ios do
  desc "Build and upload to TestFlight"
  lane :beta do
    require "fileutils"

    # ---------- errors-only log ----------
    errors_dir = "ci_logs"
    errors_log = File.join(errors_dir, "errors_only.log")
    FileUtils.mkdir_p(errors_dir)

    def append_err(path, msg)
      File.open(path, "a") { |f| f.puts(msg) }
    end

    begin
      # --- App Store Connect API key ---
      api_key = app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_filepath: "fastlane/AuthKey.p8",
        duration: 1200,
        in_house: false
      )

      # --- CI keychain ---
      is_ci = !ENV["CI"].to_s.empty?
      keychain_name = "fastlane_tmp_keychain"
      keychain_password = ENV["MATCH_PASSWORD"] || "temp_password"

      if is_ci
        sh("security create-keychain -p '#{keychain_password}' #{keychain_name}")
        sh("security default-keychain -s #{keychain_name}")
        sh("security unlock-keychain -p '#{keychain_password}' #{keychain_name}")
        sh("security set-keychain-settings -lut 21600 #{keychain_name}")
      end

      # --- Match (pull signing from ios-certificates repo) ---
      match(
        type: "appstore",
        readonly: true,
        git_url: ENV["MATCH_GIT_URL"],
        git_basic_authorization: Base64.strict_encode64("x-access-token:#{ENV['MATCH_GIT_TOKEN']}"),
        keychain_name: keychain_name,
        keychain_password: keychain_password,
        app_identifier: ENV["APP_IDENTIFIER"],
        team_id: ENV["APPLE_TEAM_ID"]
      )

      scheme = ENV["IOS_SCHEME"]

      # Prefer detected workspace, else project
      workspace = ENV["IOS_WORKSPACE"].to_s
      project   = ENV["IOS_PROJECT"].to_s

      # ============================================================
      # âœ… NEW: ROBUST BUILD NUMBER USING TIMESTAMP
      #    -> guarantees uniqueness; no more duplicate errors
      # ============================================================
      timestamp_build = Time.now.strftime("%Y%m%d%H%M%S")
      UI.message("Setting build number to #{timestamp_build} (timestamp-based)")

      # Use set_info_plist_value instead of increment_build_number for XcodeGen projects
      set_info_plist_value(
        path: "Info.plist",
        key: "CFBundleVersion",
        value: timestamp_build
      )
      # ============================================================

      build_opts = {
        scheme: scheme,
        export_method: "app-store",
        clean: true,
        silent: false,
        export_options: {
          provisioningProfiles: {
            ENV["APP_IDENTIFIER"] => "match AppStore #{ENV['APP_IDENTIFIER']}"
          }
        },
        xcargs: [
          "DEVELOPMENT_TEAM=#{ENV['APPLE_TEAM_ID']}",
          "CODE_SIGN_STYLE=Manual",
          "CODE_SIGN_IDENTITY='Apple Distribution'",
          "PROVISIONING_PROFILE_SPECIFIER='match AppStore #{ENV['APP_IDENTIFIER']}'"
        ].join(" ")
      }

      if !workspace.empty?
        build_opts[:workspace] = workspace
      else
        build_opts[:project] = project
      end

      # --- Build IPA ---
      build_app(**build_opts)

      # --- Upload to TestFlight ---
      # Wrapped in begin/rescue to handle agreement errors gracefully
      begin
        upload_to_testflight(api_key: api_key)
        UI.success("âœ… Successfully uploaded to TestFlight!")
      rescue => upload_error
        # Check if this is an agreement error
        error_message = upload_error.message.to_s
        if error_message.include?("agreement") || error_message.include?("expired")
          UI.important("âš ï¸  TestFlight upload failed due to App Store Connect agreement issue")
          UI.important("ðŸ“‹ Action Required:")
          UI.important("   1. Log into App Store Connect: https://appstoreconnect.apple.com")
          UI.important("   2. Accept any pending agreements shown on the main page")
          UI.important("   3. Re-run this workflow, or manually upload the IPA")
          UI.important("")
          UI.important("ðŸ’¡ The IPA was built successfully and is available as a workflow artifact")
          UI.important("   You can download it and upload manually if needed")

          # Don't fail the entire workflow - the build succeeded
          append_err(errors_log, "========= TESTFLIGHT UPLOAD SKIPPED =========")
          append_err(errors_log, "Reason: App Store Connect agreement needs acceptance")
          append_err(errors_log, error_message)
        else
          # Re-raise other upload errors
          raise upload_error
        end
      end

    rescue => e
      # ---------- write tight failure summary ----------
      append_err(errors_log, "========= FASTLANE FAILURE =========")
      append_err(errors_log, "Time: #{Time.now.utc}")
      append_err(errors_log, "Message: #{e.class}: #{e.message}")
      append_err(errors_log, "")
      append_err(errors_log, "Backtrace (top 30):")
      append_err(errors_log, (e.backtrace || [])[0,30].join("\n"))
      append_err(errors_log, "")

      # Try to capture most recent gym log tail + error lines
      gym_dir = File.expand_path("~/Library/Logs/gym")
      gym_logs = Dir["#{gym_dir}/*.log"].sort
      if gym_logs.any?
        latest = gym_logs.last
        append_err(errors_log, "Latest gym log: #{latest}")
        tail = `tail -n 200 "#{latest}" 2>/dev/null`
        append_err(errors_log, tail)
        append_err(errors_log, "")
        errs = `grep -E "error:|::error" "#{latest}" 2>/dev/null | tail -n 200`
        unless errs.strip.empty?
          append_err(errors_log, "Errors extracted from gym log:")
          append_err(errors_log, errs)
          append_err(errors_log, "")
        end
      else
        append_err(errors_log, "No gym logs found in #{gym_dir}")
      end

      UI.error("Build failed. See #{errors_log} for a tight summary.")
      raise e
    ensure
      # optional: clean up CI keychain
      if is_ci
        sh("security delete-keychain #{keychain_name}") rescue nil
      end
    end
  end
end